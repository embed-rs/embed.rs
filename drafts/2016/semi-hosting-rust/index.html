<!doctype html>
<html>
<head>
  <title>Semi-hosting on ARM with Rust - embed.rs</title>
  <link rel="stylesheet" type="text/css" href="/static/css/fonts.css">
  <link rel="stylesheet" type="text/css" href="/static/css/two.css">
  <link rel="stylesheet" type="text/css" href="/static/css/github.css">
  <link rel="icon" href="/static/img/icon.png" sizes="512x512" type="image/png">
  <link rel="icon" href="/static/img/icon.svg" sizes="any" type="image/svg+xml">
  <link rel="alternate" type="application/atom+xml" title="embed.rs" href="/atom.xml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<div class="container">
  <div class="navbar">
    <div><span class="logo"><a href="/">embed<span class="accent">.rs</span></a></span><br>
    <span class="slogan">Rust embedded development</span>
    </div>
    <ul class="menu">
      <li><a href="/articles/">/articles</a></li>
      <li><a href="/about/">/about</a></li>
    </ul>
    <div class="gitlink last"><a href="https://github.com/embed-rs">
      <img src="/static/img/github_light.png">
    </a></div>
  </div>
  <div class="main">
  
<div class="article">
  <h1>Semi-hosting on ARM with Rust</h1>
  <div class="info">
    by 
      <a href="https://github.com/mbr">Marc Brinkmann</a>

    &middot; October 18, 2016</div>
  <p>If a technology is in use for two decades and still has no Wikipedia entry, it seems safe to call it "a bit obscure". <em>Semi-hosting</em> is such a technology and can be a great help in debugging boards with no <a href="https://en.wikipedia.org/wiki/Input/output">IO</a> facilities other than a <a href="https://en.wikipedia.org/wiki/JTAG">JTAG</a> or another debugging port available.</p>
<p>When developing firmware for an embedded board, <code>println!</code>-style (or <code>printf</code>-style for more <em>C</em>-affine readers) debugging can be immensely useful, a quick-fix that can save a lot of time that would otherwise be spent setting breakpoints or single-stepping through a program. Being able to output text does require IO ports of some sort though, be it USB, networking or another connection to the <a href="https://en.wikipedia.org/wiki/Microcontroller">MCU</a> that the code is being run on. But the mere presence of these ports is not enough, without drivers they cannot be used, creating a classic chicken-and-egg problem when implementing said drivers.</p>
<p>There is a way around the issue: During bare-metal development, uploading new program code is often handled through a targets debugging facilities, which should include a way to set breakpoints, halt the CPU and explore memory contents as well. These functionalities can be (and have been) twisted into a full-blown RPC mechanism, as shown below.</p>
<h2>Semi-hosting, step-by-step</h2>
<p><em>Semi-hosting</em> refers to making some of the <em>host</em>'s (i.e. the computer running the debugger) functionality available to the <em>target</em>, the MCU being debugged, through the debugger itself.</p>
<ol>
<li>The target executes a <strong>breakpoint</strong> instruction with a special tag.</li>
<li>The debugging-software on the host is <strong>notified</strong> of the breakpoint.</li>
<li>Information inside the <strong>first two registers</strong> indicates which procedure should be called and points to a structure with arguments.</li>
<li>The debugger uses its memory-reading capabilities to <strong>retrieve the arguments</strong> and passes these on to the host's procedure.</li>
<li>The target's CPU is unhalted by the debugger and <strong>execution continues</strong>.</li>
</ol>
<h2>ARMv6 and ARMv7</h2>
<p>The exact process is instruction set specific, for example ARMv6 and ARMv7 use a <code>bkpt</code> instruction, while some other ARM instruction sets use an <code>svc</code> (<em>supervisor command</em>) instruction. This article will assume an ARM Cortex-M series MCU, which is using the ARMv7 style breakpoints. Additionally, instead of using any of the commercial debugging software solutions, <a href="https://en.wikipedia.org/wiki/GNU_Debugger">gdb</a> will be used as the debugger. We can now implement the process step-by-step:</p>
<h3>Halting the CPU</h3>
<p>A simple <code>bkpt 0xAB</code> inline assembly instruction is enough to halt the CPU (see the <a href="http://embed.rs/articles/2016/arm-inline-assembly-rust">inline assembly introduction</a> for help on the <code>asm!</code>-macro):</p>
<div class="highlight"><pre><span></span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;bkpt 0xAB&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The parameter <code>0xAB</code> is a magic-number taken from the <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0471g/Bgbjjgij.html">official documentation</a>, it does not have any effect on the target, neither is it passed along when the CPU halts. Instead, the debugger is expected to find the current instruction by reading the program counter and looking it up inside the binary, then to check which value is passed. If it is <code>0xAB</code>, the breakpoint is interpreted as a semi-hosting call.</p>
<p>We can now try this in gdb: A remote-debugger has been started and this is what happens when the MCU executes the <code>bkpt</code> instruction:</p>

<pre><code>Program received signal SIGTRAP, Trace/breakpoint trap.
0x080102e4 in hello_embed_rs::_rust_start::hfb6a6b3dc95a15dd ()
(gdb)</code></pre>
<p>Verifying the program counter is indeed at <code>0x80102e4</code>:</p>

<pre><code>(gdb) p/x $pc
$1 = 0x80102e4</code></pre>
<p>Checking the disassembly, we know that all the information we need is readily available. Note that the Thumb-Instruction set uses 2-byte instructions instead of 4:</p>

<pre><code>(gdb) disassemble 0x80102e4,+2
Dump of assembler code from 0x80102e4 to 0x80102e6:
=&gt; 0x080102e4 &lt;...&gt;:bkpt  0x00ab
End of assembler dump.</code></pre>
<h3>Implementing the <code>SVC_WRITE</code> call</h3>
<p>The <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0471g/Bacbedji.html"><code>SVC_WRITE</code></a> call is specified by the ARM compiler toolchain to write arbitrary data to a file descriptor on the host. The general calling convention for semi-hosting calls is as follows:</p>
<ul>
<li><code>r0</code> must contain the number indicating the type of call.</li>
<li><code>r1</code> is a pointer to a struct containing arguments for the call.</li>
<li>Each call has its own struct format.</li>
<li>A call can return either a single 32-bit integer or an address, both of which
are stored in <code>r0</code> afterwards.</li>
</ul>
<p>The ID associated with <code>SVC_WRITE</code> is <code>0x05</code>, it must be moved into register <code>r0</code>. Furthermore a parameter struct is necessary:</p>
<div class="highlight"><pre><span></span><span class="cp">#[repr(C)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">SvcWriteCall</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// the file descriptor on the host</span>
<span class="w">    </span><span class="n">fd</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// pointer to data to write</span>
<span class="w">    </span><span class="n">addr</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// length of data to write</span>
<span class="w">    </span><span class="n">len</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Armed with this definition, we can implement the SVC-calling function:</p>
<div class="highlight"><pre><span></span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">call_svc</span><span class="p">(</span><span class="n">num</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// allocate stack space for the possible result</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// move type and argument into registers r0 and r1, then trigger</span>
<span class="w">    </span><span class="c1">// breakpoint 0xAB. afterwards, save a potential return value in r0</span>
<span class="w">    </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;mov r0,$1</span><span class="se">\n\t</span><span class="s">\</span>
<span class="s">          mov r1,$2</span><span class="se">\n\t</span><span class="s">\</span>
<span class="s">          bkpt 0xAB</span><span class="se">\n\t</span><span class="s">\</span>
<span class="s">          mov $0,r0&quot;</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=ri&quot;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;ri&quot;</span><span class="p">(</span><span class="n">num</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;ri&quot;</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;r0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r1&quot;</span><span class="w"></span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="w"></span>
<span class="w">       </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// return result (== r0)</span>
<span class="w">    </span><span class="n">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The <code>"volatile"</code> option indicates that the code has side-effects and should not be by removed by optimizations. The whole function is marked <code>unsafe</code>, because we are dereferencing the <code>addr</code> pointer, albeit the host does our dirty work.</p>
<p>With the capability to perform arbitrary SVC-calls, we implement the <code>SYS_WRITE</code> function by placing the argument structure on the stack, then passing a pointer to it to <code>call_svc</code>.</p>
<div class="highlight"><pre><span></span><span class="kr">const</span><span class="w"> </span><span class="n">SYS_WRITE</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x05</span><span class="p">;</span><span class="w"></span>

<span class="sd">/// Semi-hosting: `SYS_WRITE`. Writes `data` to file descriptor `fd`</span>
<span class="sd">/// on the host. Returns `0` on success or number of unwritten bytes</span>
<span class="sd">/// otherwise.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">svc_sys_write</span><span class="p">(</span><span class="n">fd</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SvcWriteCall</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">fd</span><span class="o">:</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">addr</span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">call_svc</span><span class="p">(</span><span class="n">SYS_WRITE</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="o">&amp;</span><span class="n">args</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="n">SvcWriteCall</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="p">())</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The function is safe because all the parameters passed to <code>call_svc</code> are constant values or valid pointers; ensuring that the host's software does not have any bugs that corrupt our memory is outside the scope of our application.</p>
<p>Calling <code>svc_sys_write</code> inside <code>main()</code>:</p>
<div class="highlight"><pre><span></span><span class="c1">// fd 2 is stderr:</span>
<span class="n">svc_sys_write</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">b&quot;Hello from Rust.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Running the code again causes a <code>SIGTRAP</code> in gdb:</p>

<pre><code>Program received signal SIGTRAP, Trace/breakpoint trap.
0x080102e4 in hello_embed_rs::_rust_start::hfb6a6b3dc95a15dd ()</code></pre>
<p>Inspecting <code>r0</code> and <code>r1</code></p>

<pre><code>(gdb) p/x $r0
$1 = 0x5
(gdb) p/x $r1
$2 = 0x2002ffc8</code></pre>
<p>confirms that <code>r0</code> has the correct value of <code>0x05</code>, while <code>r1</code> points us to <code>0x2002ffc8</code>, which should be a three word structure:</p>

<pre><code>(gdb) p *0x2002ffc8
$3 = 2
(gdb) p/x *(0x2002ffc8+4)
$4 = 0x8010008
(gdb) p *(0x2002ffc8+8)
$5 = 17</code></pre>
<p>The first field is our file-descriptor <code>2</code>. The second is the address of the string to be printed, note that it is not inside the RAM area (<code>0x200xxxxxx</code>), but pointing to the flash memory (<code>0x080xxxxx</code>). The string constant is read directly from the binary! The third field denotes the <code>17</code> characters.</p>
<p>We can now print the string:</p>

<pre><code>(gdb) printf "%17s", 0x08010008
Hello from Rust.</code></pre>
<h2>Scripting the debugger</h2>
<p>After finishing the target's code, the next step is implementing a little script for the debugger to make things easier. Gdb supports Python scripting, so we will start with a few lines of Python to retrieve the current stack frame and <em>inferior</em>, gdb's term for the target, instance. Then, it is time to decode the assembly instruction and check if it is a <code>bkpt</code>:</p>
<div class="highlight"><pre><span></span><span class="c1"># get the current frame and inferior</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">selected_frame</span><span class="p">()</span>
<span class="n">inf</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">selected_inferior</span><span class="p">()</span>

<span class="c1"># retrieve instruction</span>
<span class="n">ins</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">architecture</span><span class="p">()</span><span class="o">.</span><span class="n">disassemble</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">pc</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">r&#39;^bkpt\s+((?:0x)?[0-9a-f]+)$&#39;</span><span class="p">,</span> <span class="n">ins</span><span class="p">[</span><span class="s1">&#39;asm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
</pre></div>
<p>Afterwards, we check the immediate we saved using the regular expression and compare it to <code>0xAB</code>:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">m</span><span class="p">:</span>
    <span class="n">raw</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># we&#39;ve matched a breakpoint, decode the immediate</span>
    <span class="n">bkpt_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="mi">16</span> <span class="k">if</span> <span class="n">raw</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;0x&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">10</span><span class="p">)</span>

    <span class="c1"># breakpoint 0xab indicates a semi-hosting call</span>
    <span class="k">if</span> <span class="n">bkpt_n</span> <span class="o">==</span> <span class="mh">0xAB</span><span class="p">:</span>
       <span class="c1"># ...</span>
</pre></div>
<p>Finally, we retrieve the register contents of <code>r0</code> and <code>r1</code> and call the appropriate handler:</p>
<div class="highlight"><pre><span></span><span class="c1"># retrieve the call type and obj registers</span>
<span class="c1"># note: we would like to use `Frame.read_registers()` for this,</span>
<span class="c1">#       but its only available on gdb 7.8 or newer</span>
<span class="n">r0</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">parse_and_eval</span><span class="p">(</span><span class="s1">&#39;$r0&#39;</span><span class="p">)</span>
<span class="n">r1</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">parse_and_eval</span><span class="p">(</span><span class="s1">&#39;$r1&#39;</span><span class="p">)</span>

<span class="n">call_type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
<span class="n">arg_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>

<span class="k">if</span> <span class="n">call_type</span> <span class="o">==</span> <span class="mh">0x05</span><span class="p">:</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">handle_write</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="n">arg_addr</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s1">&#39;Call type 0x{:X} not implemented&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">call_type</span><span class="p">))</span>
</pre></div>
<p>We will later combine all the code into a single class.</p>
<h3>Handling <code>SYS_WRITE</code></h3>
<p>The <code>handle_write</code> method needs to be implemented as well:</p>
<div class="highlight"><pre><span></span><span class="c1"># security, only allow fds 1 (stdout) and 2 (stderr)</span>
<span class="n">SANE_FDS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># whether or not to automatically continue execution</span>
<span class="n">CONTINUE</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c1"># argument struct has three u32 entries: fd, address, len</span>
<span class="n">buf</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span><span class="n">args_addr</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="n">fd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;lll&#39;</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>

<span class="c1"># limit length to 4M to avoid funky behavior</span>
<span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>

<span class="c1"># sanity check file descriptor</span>
<span class="k">if</span> <span class="n">fd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">SANE_FDS</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s1">&#39;Refusing to write to file descriptor {} (not in {})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">fd</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">SANE_FDS</span><span class="p">))</span>
</pre></div>
<p>Even if it is only intended to be executed during debugging using a closed system, access to arbitrary file descriptors or unchecked length reads should make the security-conscious hair on the back of your neck stand-up; for this reason we check all arguments for sanity and limit what is written to four megabytes.</p>
<p>Once we are sure our arguments are good, we can progress to read the string and print it:</p>
<div class="highlight"><pre><span></span><span class="c1"># read the memory</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>

<span class="c1"># we manually map FDs. encoding is fixed at the rust-native utf8</span>
<span class="k">if</span> <span class="n">fd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span>
<span class="k">elif</span> <span class="n">fd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span>

<span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">CONTINUE</span><span class="p">:</span>
    <span class="n">gdb</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;continue&#39;</span><span class="p">)</span>
</pre></div>
<p>An automatic continue is triggered as well if desired.</p>
<h3>The final class</h3>
<p>All the code gets combined into a <code>SemiHostHelper</code> class:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">gdb</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">class</span> <span class="nc">SemiHostHelper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">SANE_FDS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">CONTINUE</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">on_break</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="c1"># get the current frame and inferior</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">selected_frame</span><span class="p">()</span>
        <span class="n">inf</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">selected_inferior</span><span class="p">()</span>

        <span class="c1"># retrieve instruction</span>
        <span class="n">ins</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">architecture</span><span class="p">()</span><span class="o">.</span><span class="n">disassemble</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">pc</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">r&#39;^bkpt\s+((?:0x)?[0-9a-f]+)$&#39;</span><span class="p">,</span> <span class="n">ins</span><span class="p">[</span><span class="s1">&#39;asm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># we&#39;ve matched a breakpoint, decode the immediate</span>
            <span class="n">bkpt_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="mi">16</span> <span class="k">if</span> <span class="n">raw</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;0x&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">10</span><span class="p">)</span>

            <span class="c1"># breakpoint 0xab indicates a semi-hosting call</span>
            <span class="k">if</span> <span class="n">bkpt_n</span> <span class="o">==</span> <span class="mh">0xAB</span><span class="p">:</span>
                <span class="c1"># retrieve the call type and obj registers</span>
                <span class="c1"># note: we would like to use `Frame.read_registers()`</span>
                <span class="c1">#       for this, but its only available on gdb 7.8 or</span>
                <span class="c1">#       newer</span>
                <span class="n">r0</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">parse_and_eval</span><span class="p">(</span><span class="s1">&#39;$r0&#39;</span><span class="p">)</span>
                <span class="n">r1</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">parse_and_eval</span><span class="p">(</span><span class="s1">&#39;$r1&#39;</span><span class="p">)</span>

                <span class="n">call_type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
                <span class="n">arg_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">call_type</span> <span class="o">==</span> <span class="mh">0x05</span><span class="p">:</span>
                    <span class="n">cls</span><span class="o">.</span><span class="n">handle_write</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="n">arg_addr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s1">&#39;Call type 0x{:X} not implemented&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">call_type</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">handle_write</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">args_addr</span><span class="p">):</span>
        <span class="c1"># argument struct has three u32 entries: fd, address, len</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span><span class="n">args_addr</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>

        <span class="n">fd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;lll&#39;</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>

        <span class="c1"># limit length to 4M to avoid funky behavior</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>

        <span class="c1"># sanity check file descriptor</span>
        <span class="k">if</span> <span class="n">fd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">SANE_FDS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Refusing to write to file descriptor {}&#39;</span>
                <span class="s1">&#39; (not in {})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">SANE_FDS</span><span class="p">))</span>

        <span class="c1"># read the memory</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>

        <span class="c1"># we manually map FDs. encoding is fixed at the rust-native utf8</span>
        <span class="k">if</span> <span class="n">fd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">fd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">CONTINUE</span><span class="p">:</span>
            <span class="n">gdb</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;continue&#39;</span><span class="p">)</span>
</pre></div>
<p>Now it is time to load it and test it in gdb:</p>

<pre><code>(gdb) source semihosting.py
(gdb) continue
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0x080102e4 in hello_embed_rs::_rust_start::hfb6a6b3dc95a15dd ()
(gdb) pi SemiHostHelper.on_break()
Hello from Rust.</code></pre>
<h3>Setting up hooks</h3>
<p>Once the script runs correctly, we can write a start-up script for the project to make the script automatically run on each breakpoint:</p>

<pre><code>source semihosting.py
catch signal SIGTRAP

commands
pi SemiHostHelper.on_break()
end</code></pre>
<p>The <code>catch signal SIGTRAP</code> creates a <em>catchpoint</em>. A catchpoint functions like a breakpoint but triggers on signals instead, like the <code>SIGTRAP</code> caused by the CPU breakpoint. The following <code>commands</code> section defines the commands to be executed whenever the catchpoint triggers.</p>
<p>After passing the start-up script to gdb  on start using the <code>-x</code> option, gdb will automatically handle the semi-hosting breakpoints and continue execution thereafter.</p>
<h2>Conclusion</h2>
<p>Semi-hosting is another alternative to other IO methods that does not require any hardware except the likely already present debugging port. It is quite slow in comparison though and completely halts execution, so it is not suitable for high-volume or production logging. Another drawback is that if the breakpoints are not handled, execution will simply stay paused.</p>
<p>It can, however, be invaluable when debugging the IO facilities themselves. Another article will demonstrate how this can be used with the <code>embed-rs</code> libraries.</p>


  
</div>

  </div> <!-- /main -->
</div> <!-- /container -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</body>
</html>